{"StyleGraphics.lua":"-- package: base\n-- order: -20\n\nAlignmentLookUp={\n\t['TopLeft']='TopLeft',\n\t['TopCenter']='Top',\n\t['TopRight']='TopRight',\n\t['CenterLeft']='Left',\n\t['CenterCenter']='Center',\n\t['CenterRight']='Right',\n\t['BottomLeft']='BottomLeft',\n\t['BottomCenter']='Bottom',\n\t['BottomRight']='BottomRight'\n}\n\nfunction StyleText(graphics,style,bounds,text,fit)\n\tif text~=nil and string.len(text)>0 then \n\t\tlocal ldp=style.textInset.left*base.dp\n\t\tlocal rdp=style.textInset.right*base.dp\n\t\tlocal tdp=style.textInset.top*base.dp\n\t\tlocal bdp=style.textInset.bottom*base.dp\n\t\n\t\tgraphics:SetColor(style.color.red,style.color.green,style.color.blue,style.color.alpha)\n\t\tgraphics:DrawText(style.font,\n\t\t\ttext,\n\t\t\tstyle.fontSize,\n\t\t\tbounds.left+ldp,\n\t\t\tbounds.top+tdp,\n\t\t\tbounds.width-ldp-rdp,\n\t\t\tbounds.height-tdp-bdp,\n\t\t\tAlignment[AlignmentLookUp[style.verticleAlignment .. style.horizontalAlignment]],\n\t\t\tfit\n\t\t)\n\tend\nend\n\nfunction DrawImage(graphics,image,fillMode,imageCut,imageDpCut,bounds)\n\tlocal dw,dh,xp,yp\n\tif fillMode == 'Fit' then\n\t\t-- Will make sure the whole image fits leaving a margin\n\t\tdh=images[image].height*bounds.width/images[image].width\n\t\tdw=images[image].width*bounds.height/images[image].height\n\t\tif dh>bounds.height then\n\t\t\tdh=images[image].height*dw/images[image].width\n\t\telse\n\t\t\tdw=images[image].width*dh/images[image].height\n\t\tend\n\t\tgraphics:DrawImageStretch(image,bounds.left+(bounds.width-dw)/2,bounds.top+(bounds.height-dh)/2,dw,dh)\n\telseif fillMode == 'Fill' then\n\t\t-- The image will be scaled to fit cropping the sides or the top and bottom\n\t\t-- Will make sure the whole image fits leaving a margin\n\t\tdh=images[image].height*bounds.width/images[image].width\n\t\tdw=images[image].width*bounds.height/images[image].height\n\t\tif dh<bounds.height then\n\t\t\tdh=images[image].height*dw/images[image].width\n\t\telse\n\t\t\tdw=images[image].width*dh/images[image].height\n\t\tend\n\t\tgraphics:DrawImageStretch(image,bounds.left+(bounds.width-dw)/2,bounds.top+(bounds.height-dh)/2,dw,dh)\n\telseif fillMode == 'Diced' then\n\t\t-- The image is cut into 9 parts the corners fit the top and sides stretched with the middle.\n\t\tgraphics:DrawImageCut(image,bounds.left,bounds.top,bounds.width,bounds.height,imageCut.left,imageCut.right,imageCut.top,imageCut.bottom,imageDpCut.left*base.dp,imageDpCut.right*base.dp,imageDpCut.top*base.dp,imageDpCut.bottom*base.dp)\n\telseif fillMode == 'Tile' then\n\t\t-- The image is tiles to fit the area (offsets are based on the alignment)\n\t\txp=-(images[image].width-(bounds.width%images[image].width))/2\n\t\typ=-(images[image].height-(bounds.height%images[image].height))/2\n\t\tfor x=xp,bounds.width,images[image].width do\n\t\t\tfor y=yp,bounds.height,images[image].height do\n\t\t\t\tgraphics:DrawImageStretch(image,x,y,images[image].width,images[image].height)\n\t\t\tend\n\t\tend\n\telse\n\t\t-- Fit to size distorting the image to fit (default)\n\t\tgraphics:DrawImageStretch(image,bounds.left,bounds.top,bounds.width,bounds.height)\n\tend\nend\n\nfunction StyleImageActiveOrNormal(graphics,style,bounds)\n\tif StyleImageActive(graphics,style,bounds) == false then\n\t\tStyleImageNormal(graphics,style,bounds)\n\tend\nend\n\nfunction StyleImageActive(graphics,style,bounds)\n\tif style ~= nil and style.imageActive ~= nil then\n\t\tDrawImage(graphics,style.imageActive,style.imageActiveFillMode,style.imageActiveInset,style.imageActiveDpInset,bounds)\n\t\treturn true\n\tend\n\treturn false\nend\n\nfunction StyleImageNormal(graphics,style,bounds)\n\tif style ~= nil and style.imageNormal ~= nil then\n\t\tDrawImage(graphics,style.imageNormal,style.imageNormalFillMode,style.imageNormalInset,style.imageNormalDpInset,bounds)\n\t\treturn true\n\tend\n\treturn false\nend\n","Base.lua":"-- package: base\n-- order: -50\nmodel=model or {}\nmodel.pages={}\n\nbase={\n\tnextId=0,\n\tcomponents={},\n\tpanels={},\n\tbounds={}\n}\n\nfunction GenerateNextID()\n\tbase.nextId=base.nextId+1\n\treturn base.nextId\nend\n \nfunction SetPage(component,details)\n\tdetails=details or {}\n\tdetails.component=component\n\tbase.page=details\nend\n \nfunction AddComponent(name,component,details)\n\tif type(component) == 'table' and type(details) == 'table' and type(name) == 'string' then\n\t\tdetails=details or {}\n\t\tdetails.component=component\n\t\tbase.components[name]=details\n\telse\n\t\terror(\"Invalid Component\")\n\tend\nend\n\nfunction AddPanelComponent(name,component,details,layoutContraints)\n\tif type(component) == 'table' and type(details) == 'table' and type(name) == 'string' then\n\t\tdetails=details or {}\n\t\tdetails.component=component\n\t\tdetails.layoutContraints=layoutContraints\n\t\tbase.panels[name]=details\n\telse\n\t\terror(\"Invalid Panel Component\");\n\tend\n\t\nend\n\nfunction AddAction(name,action)\n\tif type(action) == 'function' then\n\t\tbase.actions[name]=action\n\tend\nend\n\nfunction BoundsContain(bounds,x,y)\n\treturn bounds.left<=x and bounds.right>=x and bounds.top<=y and bounds.bottom>=y\nend\n\nfunction BoundsConstrain(bounds,x,y)\n\tlocal cx,cy=x,y\n\tif cx<bounds.left then\n\t\tcx=bounds.left\n\tend\n\tif cx>bounds.right then\n\t\tcx=bounds.right\n\tend\n\tif cy<bounds.top then\n\t\tcy=bounds.top\n\tend\n\tif cy>bounds.bottom then\n\t\tcy=bounds.bottom\n\tend\n\treturn cx,cy\nend\n","luoop.lua":"-- package: base\n-- order: -100\n\n-----\n-- Luoop - easy and flexible object oriented library for Lua\n-- Author: Teddy Engel <engel.teddy[at]gmail.com> / @Teddy_Engel\n-- Version: 1.2\n--\n-- This is an implementation of a object-oriented Lua module, coded entirely in Lua.\n-- It is meant to be simple and flexile, since the main initial requirement was multiple inheritance and overloading + the ability\n-- to call constructors / destructors with custom parameters.\n--\n-- MIT License (MIT)\n-- Copyright (c) 2013 Teddy Engel\n\n-- Permission is hereby granted, free of charge, to any person obtaining a copy of\n-- this software and associated documentation files (the \"Software\"), to deal in\n-- the Software without restriction, including without limitation the rights to\n-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n-- the Software, and to permit persons to whom the Software is furnished to do so,\n-- subject to the following conditions:\n\n-- The above copyright notice and this permission notice shall be included in all\n-- copies or substantial portions of the Software.\n\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n-- FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n-- COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n-- IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n-- CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n--\n\n--- PRIVATE FUNCTIONS ---\nlocal function _createSuperclass(oClassDefinition, oSuperclass)\n   assert(type(oSuperclass) == 'table', '_createSuperclass expects a valid superclass')\n   assert(oSuperclass.init, '_createSuperclass expects a superclass with a constructor defined')\n   \n   -- We copy all methods / variables from the superclass to the current class\n   for sMethodName, oMethod in pairs(oSuperclass) do\n      -- Exceptions for internally used variables\n      if sMethodName ~= '__aParents'\n         and sMethodName ~= '__aAllParents'\n         and sMethodName ~= '__index' \n         and sMethodName ~= '__bSingleton' \n         and sMethodName ~= 'isSingleton' \n         and sMethodName ~= 'enableSingleton' \n         and sMethodName ~= 'disableSingleton' \n         and sMethodName ~= 'newSingleton' \n         and sMethodName ~= 'destroySingleton' then\n         oClassDefinition[sMethodName] = oMethod\n      end\n   end\n\n   if oSuperclass.__aAllParents then\n      for oParentKey, oParentValue in pairs(oSuperclass.__aAllParents) do\n         oClassDefinition.__aAllParents[oParentKey] = oParentValue\n      end\n   end\n   oClassDefinition.__aAllParents[oSuperclass] = oSuperclass\n   oClassDefinition.__aParents[oSuperclass] = oSuperclass\nend\n\n--- MAIN CALL ---\nfunction class(init, ...)\n   local oSuperClasses = {...}\n   local oClassDefinition = {}    -- a new class instance\n\n   -- Parameter to say if the class is a singleton or not\n   oClassDefinition.__bSingleton = false\n   -- Array to store the superclasses directly above this one\n   oClassDefinition.__aParents = {}\n   -- Array to store the full hierarchy of superclasses\n   oClassDefinition.__aAllParents = {}\n   \n   -- Creating all superclasses\n   for oKey, oSuperClass in pairs(oSuperClasses) do _createSuperclass(oClassDefinition, oSuperClass) end\n   \n   oClassDefinition.__index = oClassDefinition\n\n   local function __createNewObject(...)\n      local oObject = {}\n      setmetatable(oObject, oClassDefinition)\n\n      -- Use this function to know if the class has the passed class has a parent\n      oObject._hasParentClass = function(oObject, oSuperclass)\n         return oObject.__aAllParents[oSuperclass] ~= nil\n      end\n\n      -- Use this method to call a parent's method if implemented\n      oObject._parentMethod = function(oObject, oSuperclass, sMethodName, ...)\n         assert(type(oSuperclass) == 'table', 'expects a valid superclass')\n         assert(oObject._hasParentClass(oObject, oSuperclass) == true, '_parentConstructor passed super class must be valid')\n         assert(oSuperclass[sMethodName] ~= nil, '_parentMethod passed super class must implement the method')\n         return oSuperclass[sMethodName](oObject, ...)\n      end\n\n      -- Use this function to call the constructor on specific object you created, passing the superclass and variable parameters\n      oObject._parentConstructor = function(oObject, oSuperclass, ...)\n         assert(type(oSuperclass) == 'table', 'expects a valid superclass')\n         assert(oObject._hasParentClass(oObject, oSuperclass) == true, '_parentConstructor passed super class must be valid')\n\n         if oSuperclass.init then\n            oSuperclass.init(oObject, ...)\n         end\n      end\n\n      -- Use this function to call the destructor on specific object you created, passing the superclass and variable parameters\n      oObject._parentDestructor = function (oObject, oSuperclass, ...)\n         assert(type(oSuperclass) == 'table', 'expects a valid superclass')\n         assert(oObject._hasParentClass(oObject, oSuperclass) == true, '_parentDestructor passed super class must be valid')\n\n         if oSuperclass.destroy then\n            oSuperclass.destroy(oObject, ...)\n         end\n      end\n\n      -- Then the child constructor\n      if init then\n         init(oObject, ...)\n      end\n\n\t -- Flag to let other systems know this is an instance\n\t oObject.__isInstance = true\n      \n      return oObject\n   end\n\n   -- Exposes a constructor which can be called by classname(<args>)\n   local mt = {}\n\n   mt.__call = function(class_tbl, ...)\n      local oObject = nil\n      if oClassDefinition.__bSingleton == false then \n         oObject = __createNewObject(...)\n      end\n      return oObject\n   end\n   \n   -- Singleton handling\n   local oSingleton = nil\n   oClassDefinition.isSingleton = function(self)\n      return oClassDefinition.__bSingleton\n   end\n\n   oClassDefinition.enableSingleton = function(self)\n      self.__bSingleton = true\n   end\n\n   oClassDefinition.disableSingleton = function()\n      assert(oSingleton == nil, 'disableSingleton cannot be called once a singleton has been instantiated')\n      oClassDefinition.__bSingleton = false\n   end\n\n   oClassDefinition.newSingleton = function(...)\n      if oClassDefinition:isSingleton() and oSingleton == nil then \n         oSingleton = __createNewObject(...)\n      end\n      return oSingleton\n   end\n\n   oClassDefinition.destroySingleton = function(...)\n      if oSingleton ~= nil then\n         if oSingleton.destroy then\n            oSingleton:destroy(...)\n         end\n         oSingleton = nil\n      end\n   end\n\n   oClassDefinition.init = init\n   -- We expose the constructor with the method new() to allow instantiating from an existing object\n   oClassDefinition.newInstance = mt.__call\n\n   setmetatable(oClassDefinition, mt)\n   return oClassDefinition\nend","Page.lua":"-- package: base\n-- order: -20\n\nlocal function new(self, defaults)\n\ttable.copygaps(self, defaults)\n\ttable.copygaps(self, \n\t\t{\n\t\t\tname='',\n\t\t\torientation='Landscape',\n\t\t\tscreenLocked=true,\n\t\t\tgps=false,\n\t\t\tgyroscope=false,\n\t\t\taccelerometer=false,\n\t\t\tbaseComponent=nil,\n\t\t\tbounds=nil\n\t\t}\n\t)\nend\n\n\nPage = class(new)\n\nfunction Page:SetBounds(bounds)\n\tif self.bounds==nil or self.bounds.top~=bounds.top or self.bounds.bottom~=bounds.bottom or self.bounds.left~=bounds.left or self.bounds.width~=bounds.width or self.bounds.height~=bounds.height then\n\t\tself.bounds=bounds\n\t\tif self.baseComponent ~= nil then \n\t\t\tself.baseComponent:SetBounds(bounds)\n\t\tend\n\tend\nend\n\nfunction Page:Paint(graphics)\n\tself:SetBounds(base.bounds[self.orientation])\n\t\n\tif self.baseComponent ~= nil then\n\t\tself.baseComponent:Paint(graphics)\n\tend\nend\n\nfunction Page:Update(time)\n\tif self.baseComponent ~= nil then\n\t\tself.baseComponent:Update(time)\n\tend\nend\n\nfunction Page:FindComponentAt(x, y, onlyTouchableOnes)\n\tself:SetBounds(base.bounds[self.orientation])\n\t\n\tif BoundsContain(self.baseComponent.mainBounds,x,y) then\n\t\tif self.baseComponent.FindComponentAt ~= nil then\n\t\t\treturn self.baseComponent:FindComponentAt(x,y,onlyTouchableOnes)\n\t\telse\n\t\t\tif onlyTouchableOnes~=true or self.baseComponent.pressedMode.listenes then\n\t\t\t\treturn self.baseComponent;\n\t\t\tend\n\t\tend \n\tend\n\treturn nil;\nend\n\nfunction Page:Show()\n\tbase.screenLocked=self.screenLocked\n\tenvironment:StopSleep(base.screenLocked);\n\t\n\tself:SetBounds(base.bounds[self.orientation])\n\n\tbase.orientation=self.orientation\n\tif base.orientation==\"Landscape\" then\n\t\tenvironment:SetLandscape();\n\telse\n\t\tenvironment:SetPortrait();\n\tend\nend\n\nfunction Page:Hide()\nend\n\nSetPage(Page,{\n{name='Page/Name',property='name',type='Display'},\n{name='Page/Orientation',property='orientation',type='Selection',options='Landscape,Portrait',default='Landscape'},\n{name='Behaviour/ScreenLocked',property='screenLocked',type='Boolean',default=true},\n{name='Behaviour/GPS',property='gps',type='Boolean',default=false},\n{name='Behaviour/Gyroscope',property='gyroscope',type='Boolean',default=false},\n{name='Behaviour/Accelerometer',property='accelerometer',type='Boolean',default=false}\n})\n","list.lua":"-- package: base\n-- order: -100\n\nlist = {}\nlist.__index = list\n\nsetmetatable(list, { __call = function(_, ...)\n\tlocal t = setmetatable({ length = 0 }, list)\n\tfor _, v in ipairs{...} do t:push(v) end\n\treturn t\nend })\n\nfunction list:push(t)\n\tif self.last then\n\t\tself.last._next = t\n\t\tt._prev = self.last\n\t\tself.last = t\n\telse\n\t\t-- this is the first node\n\t\tself.first = t\n\t\tself.last = t\n\tend\n\t\n\tself.length = self.length + 1\nend\n\nfunction list:unshift(t)\n\tif self.first then\n\t\tself.first._prev = t\n\t\tt._next = self.first\n\t\tself.first = t\n\telse\n\t\tself.first = t\n\t\tself.last = t\n\tend\n\t\n\tself.length = self.length + 1\nend\n\nfunction list:insert(t, after)\n\tif after then\n\t\tif after._next then\n\t\t\tafter._next._prev = t\n\t\t\tt._next = after._next\n\t\telse\n\t\t\tself.last = t\n\t\tend\n\t\t\n\t\tt._prev = after    \n\t\tafter._next = t\n\t\tself.length = self.length + 1\n\telseif not self.first then\n\t\t-- this is the first node\n\t\tself.first = t\n\t\tself.last = t\n\tend\nend\n\nfunction list:pop()\n  if not self.last then return end\n  local ret = self.last\n  \n  if ret._prev then\n    ret._prev._next = nil\n    self.last = ret._prev\n    ret._prev = nil\n  else\n    -- this was the only node\n    self.first = nil\n    self.last = nil\n  end\n  \n  self.length = self.length - 1\n  return ret\nend\n\nfunction list:shift()\n  if not self.first then return end\n  local ret = self.first\n  \n  if ret._next then\n    ret._next._prev = nil\n    self.first = ret._next\n    ret._next = nil\n  else\n    self.first = nil\n    self.last = nil\n  end\n  \n  self.length = self.length - 1\n  return ret\nend\n\nfunction list:remove(t)\n  if t._next then\n    if t._prev then\n      t._next._prev = t._prev\n      t._prev._next = t._next\n    else\n      -- this was the first node\n      t._next._prev = nil\n      self._first = t._next\n    end\n  elseif t._prev then\n    -- this was the last node\n    t._prev._next = nil\n    self._last = t._prev\n  else\n    -- this was the only node\n    self._first = nil\n    self._last = nil\n  end\n\n  t._next = nil\n  t._prev = nil\n  self.length = self.length - 1\nend\n\nlocal function iterate(self, current)\n  if not current then\n    current = self.first\n  elseif current then\n    current = current._next\n  end\n  \n  return current\nend\n\nfunction list:iterate()\n  return iterate, self, nil\nend","Main.lua":"-- package: base\n-- order: -1\n\nfunction SetBounds(bounds)\n\t-- Calculate Display Pixels as 160th of an inch.\n\tbase=base or {}\n\tbase.dp=environment:GetDpi()/160\n\t\n\tif bounds.height > bounds.width then\n\t\tbase.bounds.Landscape={top=bounds.left,left=bounds.top,right=bounds.bottom,bottom=bounds.right,width=bounds.height,height=bounds.width}\n\t\tbase.bounds.Portrait=bounds\n\telse\n\t\tbase.bounds.Portrait={top=bounds.left,left=bounds.top,right=bounds.bottom,bottom=bounds.right,width=bounds.height,height=bounds.width}\n\t\tbase.bounds.Landscape=bounds\n\tend\nend\n\npressedComponents={mustReleaseBeforeTouch={},touchCounters={}}\n\nfunction Paint(graphics)\n\tbase.repaint=false;\n\n\tif currentPage~=nil then\n\t\tcurrentPage:Paint(graphics)\n\tend\nend\n\nfunction RePaint(component)\n\tbase.repaint=true;\nend\n\nfunction AddModelListener(itemName,functionToCall) \n\tmodelListeners=modelListeners or {}\n\n\tif modelListeners[itemName] == nil then\n\t\tmodelListeners[itemName]=list({callback=functionToCall}) \n\telse\n\t\tmodelListeners[itemName]:push({callback=functionToCall})\n\tend\nend\n\nfunction RemoveModelListener(itemName,functionToCall) \n\tmodelListeners=modelListeners or {}\n\n\tif modelListeners[itemName] ~= nil then\n\t\tfor v in modelListeners[itemName]:iterate() do \n\t\t\tif v.callback==functionToCall then\n\t\t\t\tmodelListeners[itemName]:remove(v)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction ModelChanged(itemName,itemValue)\n\tif type(itemValue) == \"string\" or type(itemValue) == \"number\" or type(itemValue) == \"boolean\" and itemValue ~= nil then\n\t\tprint('ModelChanged[' .. itemName .. ']=' .. tostring(itemValue))\n\telse\n\t\tprint('ModelChanged[' .. itemName .. ']= {?}' )\n\tend\n\tmodelListeners=modelListeners or {}\n\tlocal l=modelListeners[itemName]\n\tif l~=nil then \n\t\tfor v in l:iterate() do \n\t\t\tv.callback(itemName,itemValue)\n\t\tend\n\tend\nend\n\nfunction SendAction(action,params)\n\tenvironment:SendAction(action,params)\nend\n\nfunction AddTickHook(hookFunction)\n\tif base.tickHooks == nil then\n\t\tbase.tickHooks=list({hookFunction=hookFunction})\n\telse\n\t\tbase.tickHooks:push({hookFunction=hookFunction})\n\tend\nend\n\nbase.oldSeconds=0\n\nfunction Tick()\n\tlocal seconds=environment:GetSeconds()\n\tlocal timeBlock={seconds=seconds,deltaTime=seconds-base.oldSeconds}\n\tif currentPage~=nil then\n\t\tcurrentPage:Update(timeBlock)\n\tend\n\tbase.oldSeconds=seconds\n\tif base.repaint then\n\t\tenvironment:Repaint()\n\tend\n\tif base.tickHooks ~= nil then\n\t\tfor hook in base.tickHooks:iterate() do \n\t\t\thook.hookFunction(timeBlock)\n\t\tend\n\tend\nend\n\nfunction Vibrate(durationMs)\n\tenvironment:Vibrate(durationMs)\nend\n\nfunction SetCurrentPage(pageName)\n\tif pageName~=null and (currentPage==nil or currentPage.name~=pageName) then\n\t\tif currentPage ~= nil then\n\t\t\tcurrentPage:Hide()\n\t\tend\n\t\tReleaseAll()\n\t\tcurrentPage=project.pages[pageName]\n\t\tmodel.page=pageName\n\t\tif currentPage~=nil then\n\t\t\tcurrentPage:Show()\n\t\t\tRePaint(currentPage.baseComponent)\n\t\telse\n\t\t\tprint(\"Unable to find page '\" .. pageName .. \"'\");\n\t\tend\n\tend\nend\n\nfunction Pressed(id, x, y)\n\tif pressedComponents.mustReleaseBeforeTouch[id]==nil then\n\t\tlocal rx,ry=x,y\n\t\t-- print('Pressed ' .. id .. ',' .. x .. ',' .. y)\n\t \n\t\t-- Clear or continue pressed on older component\n\t\tif pressedComponents[id]~=nil then\n\t\t\t--print('Found ' .. table.tostring(pressedComponents[id].pressedMode))\n\t\t\tif pressedComponents[id].pressedMode.locked then\n\t\t\t\tx,y=BoundsConstrain(pressedComponents[id].mainBounds,x,y)\n\t\t\t\t--print('Contrained')\n\t\t\telse\n\t\t\t\tif BoundsContain(pressedComponents[id].mainBounds,x,y)==false then\n\t\t\t\t\tpressedComponents[id]:Released(id, x, y, rx, ry)\n\t\t\t\t\tpressedComponents.touchCounters[pressedComponents[id].__id]=nil\n\t\t\t\t\tpressedComponents[id]=nil\n\t\t\t\tend\n\t\t\tend\t\n\t\tend\n\t\n\t\t-- If none then find one\n\t\tif pressedComponents[id]==nil then\n\t\t\tpressedComponents[id]=currentPage:FindComponentAt(x ,y, true)\n\t\n\t\t\t-- Ignore if we only want one press to be passed to this component\n\t\t\tif id~=nil and pressedComponents[id]~=nil and pressedComponents[id].pressedMode.single and pressedComponents.touchCounters[pressedComponents[id].__id]~=nil then\n\t\t\t\tpressedComponents[id]=nil\n\t\t\tend\n\t\t\t\n\t\tend\n\t\n\t\t-- If one called pressed\n\t\tif pressedComponents[id]~=nil then\n\t\t\tpressedComponents.touchCounters[pressedComponents[id].__id] = true\n\t\t\t--print('Pressed ' .. id .. ',' .. (x-pressedComponents[id].mainBounds.left) .. ',' .. (y-pressedComponents[id].mainBounds.top))\n\t\t\tpressedComponents[id]:Pressed(id, x-pressedComponents[id].mainBounds.left, y-pressedComponents[id].mainBounds.top, rx, ry)\n\t\t\t--print('Pressed component ' .. table.tostring(pressedComponents[id]))\n\t\tend\n\tend\t\t\nend\n\nfunction Released(id, x, y)\n\tif pressedComponents.mustReleaseBeforeTouch[id] then\n\t\tpressedComponents.mustReleaseBeforeTouch[id]=nil;\n\telse\n\t\t-- print('Released ' .. id .. ',' .. x .. ',' .. y)\n\t\tif pressedComponents[id]~=nil then\n\t\t\t--print('Released ' .. id .. ',' .. (x-pressedComponents[id].mainBounds.left) .. ',' .. (y-pressedComponents[id].mainBounds.top))\n\t\t\tpressedComponents.touchCounters[pressedComponents[id].__id]=nil\n\t\t\tpressedComponents[id]:Released(id, x-pressedComponents[id].mainBounds.left, y-pressedComponents[id].mainBounds.top, x, y)\n\t\t\tpressedComponents[id]=nil\n\t\tend\t\n\tend\nend\n\nfunction ReleaseAll()\n\tlocal mustReleaseBeforeTouch={}\n\tfor id, component in pairs(pressedComponents) do\n\t\tif component~=nil and component.Released~=nil then\n\t\t\tcomponent:Released(id, 0, 0, 0, 0)\n\t\t\tmustReleaseBeforeTouch[id]=true\n\t\tend\n\tend\n\tpressedComponents={touchCounters={},mustReleaseBeforeTouch=mustReleaseBeforeTouch}\nend\n","Utils.lua":"-- package: base\n-- order: -100\nfunction table.val_to_str ( v , space )\n\tspace = space or \"\"\n\tif \"string\" == type( v ) then\n\t\tv = string.gsub( v, \"\\n\", \"\\\\n\" )\n\t\tif string.match( string.gsub(v,\"[^'\\\"]\",\"\"), '^\"+$' ) then\n\t\t\treturn \"'\" .. v .. \"'\"\n\t\tend\n\t\treturn '\"' .. string.gsub(v,'\"', '\\\\\"' ) .. '\"'\n\telse\n\t\treturn \"table\" == type( v ) and table.tostring( v, space ) or tostring( v )\n\tend\nend\n\nfunction table.key_to_str ( k )\n\tif \"string\" == type( k ) and string.match( k, \"^[_%a][_%a%d]*$\" ) then\n\t\treturn k\n\telse\n\t\treturn \"[\" .. table.val_to_str( k ) .. \"]\"\n\tend\nend\n\nfunction table.tostring( tbl, space )\n\tlocal oldSpace = space or \"\"\n\tspace = oldSpace .. \"    \" \n\tlocal result, done = {}, {}\n\tfor k, v in ipairs( tbl ) do\n\t\tif type(v) ~= \"function\" then\n\t\t\ttable.insert( result, table.val_to_str( v , space ) )\n\t\tend\n\t\tdone[ k ] = true\n\tend\n\tfor k, v in pairs( tbl ) do\n\t\tif not done[ k ] then\n\t\t\tif type(v) ~= \"function\" then\n\t\t\t\ttable.insert( result, table.key_to_str( k ) .. \"=\" .. table.val_to_str( v , space ) )\n\t\t\tend\n\t\tend\n\tend\n\treturn \"{\\n\" .. space .. table.concat( result, \",\\n\" .. space ) .. \"\\n\" .. oldSpace ..  \"}\"\nend\n\nfunction table.copygaps(source, from)\n\tif from ~= nil then\n\t\tfor k, v in pairs(from) do\n\t\t\tif source[k] == nil then\n\t\t\t\tif type(v) == 'table' and v.__isInstance == nil then\n\t\t\t\t\tsource[k] = {}\n\t\t\t\t\ttable.copygaps(source[k],v)\n\t\t\t\telseif type(v) ~= 'function' then\n\t\t\t\t\tsource[k] = v\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction table.copyinto(source, from)\n\tif from ~= nil then\n\t\tfor k, v in pairs(from) do\n\t\t\tif type(v) == 'table' and v.__isInstance == nil then\n\t\t\t\tsource[k] = {}\n\t\t\t\ttable.copygaps(source[k],v)\n\t\t\telseif type(v) ~= 'function' then\n\t\t\t\tsource[k] = v\n\t\t\tend\n\t\tend\n\tend\nend"}